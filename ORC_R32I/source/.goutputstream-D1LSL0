///////////////////////////////////////////////////////////////////////////////
// File name    : FIR_Filter.v
// Author       : Jose R Garcia
// Create Date  : 18/05/2020 19:25:32
// Project Name : Reusable Unit Library
// Unit Name    : FIR_Filter
// Description  : Scalable FIR filter with adjustable fixed point generic
//
// Additional Comments:
//    Coefficients have to be generate in Octave/Matlab.
///////////////////////////////////////////////////////////////////////////////

module FIR_Filter #(parameter P_COEFFICIENTS_MSB  = 15,   // xxxx.XXXX digits after the point
                              P_NUM_COEFFICIENTS  = 32,   // Number of filter coefficients
                              P_DATA_MSB          = 15,   // Must be smaller than g_IntegerDigits
                              P_WRITE_ADDRESS_MSB = 4,     // log2(P_NUM_COEFFICIENTS)-1
                              P_SYNC_RESET_EN     = 1
                              )
  (
   // Input Signals
   input i_clk,         // Main Clock
   input i_reset_sync,  // Synchronous Reset
   input i_reset_async, // Synchronous Reset
   // Streaming Data Signals
   output                o_ready_in,
   input                 i_valid_in,
   input  [P_DATA_MSB:0] i_data_in,  // Input Data
   input                 i_ready_out,
   output                o_valid_out,
   output [P_DATA_MSB:0] o_data_out, // Ouput Data
   // Asynch Memory Write Interface
   input                          i_wselect,    //
   input                          i_write,      //
   output                         o_wack,       //
   input  [P_COEFFICIENTS_MSB:0]  i_write_data, //
   input  [P_WRITE_ADDRESS_MSB:0] i_write_addr  //
  );

  /////////////////////////////////////////////////////////////////////////////
  // Internal Parameter Declarations
  /////////////////////////////////////////////////////////////////////////////
  localparam LP_GAIN_NORMALIZATION = 2**((P_DATA_MSB+1)/2);
  localparam LP_SHIFT_DEC_POINT    = 16;//$clog2(LP_GAIN_NORMALIZATION);
  /////////////////////////////////////////////////////////////////////////////
  // Internal Signal Declarations
  /////////////////////////////////////////////////////////////////////////////
  // Streaming In
  reg r_ready_in;
  reg signed [P_DATA_MSB:0] r_data_in;
  // Streaming Out
  reg r_valid_out;
  // Accumulator Process
  reg signed [P_DATA_MSB:0]         r_data_buffer[0:P_NUM_COEFFICIENTS-1]; // Adder and Multiplication accumulator.
  reg signed [P_COEFFICIENTS_MSB:0] r_coefficients[0:P_NUM_COEFFICIENTS-1];// Adder and Multiplication accumulator.
  reg signed [P_DATA_MSB:0]         r_data_buffer_out;
  // Memory Write interface Signals
  reg r_wack; //
  // Counter
  integer jj;

  /////////////////////////////////////////////////////////////////////////////
  //            ********      Architecture Declaration      ********
  /////////////////////////////////////////////////////////////////////////////

  // Ready assignment
  assign o_ready_in = r_ready_in | i_valid_in;
  /////////////////////////////////////////////////////////////////////////////
  // Process     : Accumulator Process
  // Description : Accumulates the filtered samples.
  /////////////////////////////////////////////////////////////////////////////
  always @(negedge i_clk or posedge i_reset_async) begin
    if (i_reset_async == 1'b1) begin
      // Reset Signals
      r_valid_out <= 1'b0;
      r_data_in   <= 'b0;
    end
    else if(i_reset_sync == 1'b1 && P_SYNC_RESET_EN == 1) begin
      // Reset Signals
      r_valid_out <= 1'b0;
      r_data_in   <= 'b0;
    end
    else if (i_wselect == 1'b0 && r_ready_in && 1'b1 && i_valid_in == 1'b1) begin
      // Create r_valid_data_in
      r_valid_out <= 1'b1;
      r_data_in   <= i_data_in;
    end
    else if (i_wselect == 1'b1 || i_valid_in == 1'b0) begin
      // Create r_valid_data_in
      r_valid_out <= 1'b0;
      r_data_in   <= 'b0;
    end
  end
  // Assign register values to output signals
  assign r_ready_in  = !i_wselect & i_ready_out;
  assign o_valid_out = r_valid_out;

  assign r_data_buffer[0] = r_data_in;

  genvar i;
  generate  // MAC_GEN
    for (i=0; i < P_NUM_COEFFICIENTS-1; i=i+1) begin
     Mul_Acc #(P_COEFFICIENTS_MSB, P_DATA_MSB ) MACC_0
      (
       // Control
       .i_clear(i_wselect),
       // Streaming Data Signals
       .i_mac_data_in(r_data_buffer[i]),      // Input Data
       .i_mac_coefficient_in(r_coefficients[i]), //
       .o_mac_data_out(r_data_buffer[i+1])    // Ouput Data
      );
    end
  endgenerate // MAC_GEN


   Mul_Acc #(P_COEFFICIENTS_MSB, P_DATA_MSB ) MACC_32
    (
     // Control
     .i_clear(i_wselect),
     // Streaming Data Signals
     .i_mac_data_in(r_data_buffer[P_NUM_COEFFICIENTS-1]),      // Input Data
     .i_mac_coefficient_in(r_coefficients[P_NUM_COEFFICIENTS-1]), //
     .o_mac_data_out(r_data_buffer_out)    // Ouput Data
    );

  assign o_data_out = r_data_buffer_out;

  /////////////////////////////////////////////////////////////////////////////
  // Process     : Asynch Memory Write Data Process
  // Description : Creates a write interface
  /////////////////////////////////////////////////////////////////////////////
  always @(negedge i_clk or posedge i_reset_async) begin
    if (i_reset_async == 1'b1) begin
      // Reset Signals
      for(jj = 0; jj < P_NUM_COEFFICIENTS; jj = jj+1)
        r_coefficients[jj] <= 'h0;
    end
    else if(i_reset_sync == 1'b1 && P_SYNC_RESET_EN == 1) begin
      // Reset Signals
      r_valid_out <= 1'b0;
      r_data_in   <= 'b0;
    end
    else if (i_wselect == 1'b1 && i_write == 1'b1 && r_wack == 1'b0) begin
        r_coefficients[i_write_addr] <= i_write_data;
    end
  end

  /////////////////////////////////////////////////////////////////////////////
  // Process     : Asynch Memory Write Acknowledge Process
  // Description : Creates a write interface
  /////////////////////////////////////////////////////////////////////////////
  always @(negedge i_clk or posedge i_reset_async) begin
    if (i_reset_async == 1'b1) begin
      // Reset Signals
      r_wack <= 1'b0;
    end
    else if(i_reset_sync == 1'b1 && P_SYNC_RESET_EN == 1) begin
      // Reset Signals
      r_valid_out <= 1'b0;
      r_data_in   <= 'b0;
    end
    else if (i_wselect == 1'b1) begin
      if (i_write == 1'b0) begin
        r_wack <= 1'b0;
      end
      else begin
        r_wack <= 1'b1;
      end
    end
  end

  assign o_wack = r_wack;

endmodule // FIR_Filter
