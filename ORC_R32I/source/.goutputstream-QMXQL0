///////////////////////////////////////////////////////////////////////////////
// File name    : FIR_Filter.v
// Author       : Jose R Garcia
// Create Date  : 18/05/2020 19:25:32
// Project Name : Reusable Unit Library
// Unit Name    : FIR_Filter
// Description  : Scalable FIR filter with adjustable fixed point generic
//
// Additional Comments:
//    Coefficients have to be generate in Octave/Matlab.
///////////////////////////////////////////////////////////////////////////////
//`include Mul_Acc.v

module FIR_Filter #(parameter P_COEFFICIENTS_MSB  = 15,   // xxxx.XXXX digits after the point
                              P_NUM_COEFFICIENTS  = 2,   // Number of filter coefficients
                              P_DATA_MSB          = 15,   // Must be smaller than g_IntegerDigits
                              P_WRITE_ADDRESS_MSB = 3     // log2(P_NUM_COEFFICIENTS)-1
                              )
  (
   // Input Signals
   input i_clk,   // Main Clock
   input i_reset, // Synchronous Reset
   // Streaming Data Signals
   output                o_ready_in,
   input                 i_valid_in,
   input  [P_DATA_MSB:0] i_data_in,  // Input Data
   input                 i_ready_out,
   output                o_valid_out,
   output [P_DATA_MSB:0] o_data_out, // Ouput Data
   // Asynch Memory Write Interface
   input                          i_wselect,    //
   input                          i_write,      //
   output                         o_wack,       //
   input  [P_COEFFICIENTS_MSB:0]  i_write_data, //
   input  [P_WRITE_ADDRESS_MSB:0] i_write_addr  //
  );

  ////////////////////////////////////////////////////////////////////////////
  // Internal Parameter Declarations
  ////////////////////////////////////////////////////////////////////////////
  localparam LP_GAIN_NORMALIZATION = 2**((P_DATA_MSB+1)/2);
  localparam LP_SHIFT_DEC_POINT    = 16;//$clog2(LP_GAIN_NORMALIZATION);
  localparam LP_ACCU_MSB           = ((P_DATA_MSB+P_COEFFICIENTS_MSB+1)/2)-1;
  /////////////////////////////////////////////////////////////////////////////
  // Internal Signal Declarations
  /////////////////////////////////////////////////////////////////////////////
  // Streaming In
  reg r_ready_in;
  // Streaming Out
  reg r_data_out;
  reg r_valid_out;
  // Accumulator Process
  reg signed [P_DATA_MSB:0]         r_data_buffer[0:P_NUM_COEFFICIENTS-1]; // Adder and Multiplication accumulator.
  reg signed [P_COEFFICIENTS_MSB:0] r_coefficients[0:P_NUM_COEFFICIENTS-1];// Adder and Multiplication accumulator.
  reg signed [LP_ACCU_MSB:0]        r_accumulator; // Adder and Multiplication accumulator.
  // Memory Write interface Signals
  reg r_wack; //
  // Counter
  integer ii;
  integer jj;
  /////////////////////////////////////////////////////////////////////////////
  //            ********      Architecture Declaration      ********
  /////////////////////////////////////////////////////////////////////////////
  // Ready assignment
  assign o_ready_in = r_ready_in | i_valid_in;
  /////////////////////////////////////////////////////////////////////////////
  // Process     : Accumulator Process
  // Description : Accumulates the filtered samples.
  /////////////////////////////////////////////////////////////////////////////
  always @(negedge i_clk) begin
    if (i_reset == 1'b1) begin
      // Reset Signals
      r_valid_out      <= 1'b0;
      r_data_out       <= 'b0;
      r_data_buffer[0] <= 'b0;
    end
    else if (i_wselect == 1'b0 && r_ready_in && 1'b1 && i_valid_in == 1'b1) begin
      // Create r_valid_data_in
      r_valid_out      <= 1'b1;
      r_data_buffer[0] <= i_data_in;
    end
    else if (i_wselect == 1'b1 || i_valid_in == 1'b0) begin
      // Create r_valid_data_in
      r_valid_out      <= 1'b0;
      r_data_buffer[0] <= 'b0;
    end
  end
  //
  //assign r_data_buffer[0] = (!i_wselect & r_ready_in & i_valid_in) ? i_data_in : 'b0;
  // Assign register values to output signals
  assign r_ready_in  = !i_wselect & i_ready_out;
  assign o_valid_out = r_valid_out;

  /////////////////////////////////////////////////////////////////////////////
  // Process     : Shift Process
  // Description : .
  /////////////////////////////////////////////////////////////////////////////
  always @(negedge i_clk) begin
    if (i_reset == 1'b1) begin
        r_accumulator <= 'b0;
    end
    else begin
      for (ii=0; ii < P_NUM_COEFFICIENTS; i=i+1) begin
      r_data_buffer[i+1] <= r_data_buffer[i];
    end
  end

  genvar i;
  generate  // MAC_GEN
    for (i=1; i < P_NUM_COEFFICIENTS; i=i+1) begin : generate_MACC
     /////////////////////////////////////////////////////////////////////////////
     // Process     : Accumulator Process
     // Description : Accumulates the filtered samples.
     /////////////////////////////////////////////////////////////////////////////
     always @* begin
   		 // Do the convolution. This is a Multiply then add then shift operation.
       r_accumulator = (r_data_buffer[0]*i_coefficient[0]);
       r_accumulator = r_accumulator+(r_data_buffer[i]*i_coefficient[i]);
     end
  endgenerate // MAC_GEN

  assign o_data_out = r_accumulator;

  /////////////////////////////////////////////////////////////////////////////
  // Process     : Asynch Memory Write Data Process
  // Description : Creates a write interface
  /////////////////////////////////////////////////////////////////////////////
  always @(negedge i_clk) begin
    if (i_reset == 1'b1) begin
      // Reset Signals
      for(jj = 0; jj < P_NUM_COEFFICIENTS; jj = jj+1)
        r_coefficients[jj] <= 'h0;
    end
    else if (i_wselect == 1'b1 && i_write == 1'b1 && r_wack == 1'b0) begin
        r_coefficients[i_write_addr] <= i_write_data;
    end
  end

  /////////////////////////////////////////////////////////////////////////////
  // Process     : Asynch Memory Write Acknowledge Process
  // Description : Creates a write interface
  /////////////////////////////////////////////////////////////////////////////
  always @(negedge i_clk) begin
    if (i_reset == 1'b1) begin
      // Reset Signals
      r_wack <= 1'b0;
    end
    else if (i_wselect == 1'b1) begin
      if (i_write == 1'b0) begin
        r_wack <= 1'b0;
      end
      else begin
        r_wack <= 1'b1;
      end
    end
  end

  assign o_wack = r_wack;

endmodule // FIR_Filter
