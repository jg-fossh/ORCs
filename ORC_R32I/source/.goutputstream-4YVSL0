///////////////////////////////////////////////////////////////////////////////
// File name    : FIR_Filter.v
// Author       : Jose R Garcia
// Create Date  : 18/05/2020 19:25:32
// Project Name : Reusable Unit Library
// Unit Name    : FIR_Filter
// Description  : Scalable FIR filter with adjustable fixed point generic
//
// Additional Comments:
//    Coefficients have to be generate in Octave/Matlab. Transposed.
///////////////////////////////////////////////////////////////////////////////

module FIR_Filter #(parameter P_COEFFICIENTS_MSB  = 0, // xxxx.XXXX digits after the point
                              P_NUM_COEFFICIENTS  = 1, // Number of filter coefficients
                              P_DATA_MSB          = 0, // Must be smaller than g_IntegerDigits
                              P_WRITE_ADDRESS_MSB = 0  // log2(P_NUM_COEFFICIENTS)-1
                              )
  (
   // Input Signals
   input i_clk,         // Main Clock
   input i_reset_sync,  // Synchronous Reset
   // Streaming Data Signals
   output                o_ready_in,  // Streaming Ready
   input                 i_valid_in,  // Streaming Input Data Valid
   input  [P_DATA_MSB:0] i_data_in,   // Streaming Input Data
   input                 i_ready_out, // Streaming Destination Ready
   output                o_valid_out, // Streaming Output Data Valid
   output [P_DATA_MSB:0] o_data_out,  // Streaming Output Data
   // Asynch Memory Write Slave Interface
   input                          i_slave_wselect,    // Memory Write Slave Device Select.
   input                          i_slave_write,      // Memory Write Slave Signal
   output                         o_slave_wack,       // Memory Write Slave Acknowledge
   input  [P_COEFFICIENTS_MSB:0]  i_slave_write_data, // Memory Write Slave Data
   input  [P_WRITE_ADDRESS_MSB:0] i_slave_write_addr  // Memory Write Slave Address
  );

  /////////////////////////////////////////////////////////////////////////////
  // Internal Parameter Declarations
  /////////////////////////////////////////////////////////////////////////////
  localparam LP_ACCU_MSB = (P_DATA_MSB+P_COEFFICIENTS_MSB+2)-1;
  /////////////////////////////////////////////////////////////////////////////
  // Internal Signal Declarations
  /////////////////////////////////////////////////////////////////////////////
  // Streaming In
  reg r_ready_in;  // pipeline ready
  // Streaming Out
  reg r_valid_out; // pipeline valid
  // Accumulator Process
  reg signed [P_DATA_MSB:0]  r_data_buffer[0:P_NUM_COEFFICIENTS-1]; // Data Shift buffer.
  reg signed [LP_ACCU_MSB:0] r_product[0:P_NUM_COEFFICIENTS-1];     // Array of Multiplication products.
  reg signed [LP_ACCU_MSB:0] r_product_tmp;                         // Holds the product of the Multiply operation.
  reg signed [P_DATA_MSB:0]  r_accumulator[0:P_NUM_COEFFICIENTS-1]; // Array of accumulated values.
  // Memory Write interface Signals
  reg                               r_wack;                                // Write acknowledge
  reg signed [P_COEFFICIENTS_MSB:0] r_coefficients[0:P_NUM_COEFFICIENTS-1];// Adder and Multiplication accumulator.
  // Counter
  integer ii; // r_data_buffer
  integer jj; // r_coefficients
  integer hh; // r_product

  /////////////////////////////////////////////////////////////////////////////
  //            ********      Architecture Declaration      ********
  /////////////////////////////////////////////////////////////////////////////

  // Ready assignment
  assign o_ready_in = r_ready_in | i_valid_in;
  /////////////////////////////////////////////////////////////////////////////
  // Process     : Accumulator Process
  // Description : Accumulates the filtered samples.
  /////////////////////////////////////////////////////////////////////////////
  always @(negedge i_clk) begin
    if(i_reset_sync == 1'b1) begin
      // Synchronous Reset
      r_valid_out <= 1'b0;
      for (ii = 0; ii < P_NUM_COEFFICIENTS; ii = ii+1) begin
        r_data_buffer[ii] <= 'b0;
      end
    end
    else if (i_slave_wselect == 1'b0 && r_ready_in && 1'b1 && i_valid_in == 1'b1) begin
      // Create pipeline valid
      r_valid_out <= 1'b1;
      // Shift data in
      r_data_buffer[0] <= i_data_in;
      for (ii = 0; ii < P_NUM_COEFFICIENTS-1; ii = ii+1) begin
        // Shift data in.
        r_data_buffer[ii+1] <= r_data_buffer[ii];
      end
      // First Multiply and Accumulator (MACC)
      r_product_tmp    =  (r_data_buffer[0]*r_coefficients[0]);
      r_product[0]     <= r_product_tmp;
      r_accumulator[0] <= {r_product_tmp[LP_ACCU_MSB],
        r_product_tmp[LP_ACCU_MSB-2:P_DATA_MSB]};
      for (hh = 0; hh < P_NUM_COEFFICIENTS-1; hh = hh+1) begin
        // Generate the res of the MACC.
        r_product[hh+1]     <= r_data_buffer[hh+1] * r_coefficients[hh+1];
        r_accumulator[hh+1] <= r_accumulator[hh] + {
          r_product[hh+1][LP_ACCU_MSB],
          r_product[hh+1][LP_ACCU_MSB-2:P_DATA_MSB]};
      end
    end
    else if (i_slave_wselect == 1'b1 || i_valid_in == 1'b0) begin
      // Create pipeline valid
      r_valid_out <= 1'b0;
    end
  end
  // Assign register values to output signals
  assign r_ready_in  = !i_slave_wselect & i_ready_out;
  assign o_valid_out = r_valid_out;
  //assign o_data_out  = r_accumulator[P_NUM_COEFFICIENTS-1];
  assign o_data_out  = r_accumulator[P_NUM_COEFFICIENTS-1]*(-1);

  /////////////////////////////////////////////////////////////////////////////
  // Process     : Asynch Memory Write Data Process
  // Description : Creates a write interface
  /////////////////////////////////////////////////////////////////////////////
  always @(negedge i_clk) begin
     if(i_reset_sync == 1'b1) begin
      // Synchronous Reset
      for(jj = 0; jj < P_NUM_COEFFICIENTS; jj = jj+1)
        r_coefficients[jj] <= 'h0;
    end
    else if (i_slave_wselect == 1'b1 && i_slave_write == 1'b1 && r_wack == 1'b0) begin
      // Write the data to the memory space to the specified address.
      r_coefficients[i_slave_write_addr] <= i_slave_write_data;
    end
  end

  /////////////////////////////////////////////////////////////////////////////
  // Process     : Asynch Memory Write Acknowledge Process
  // Description : Creates a write interface
  /////////////////////////////////////////////////////////////////////////////
  always @(negedge i_clk) begin
    if(i_reset_sync == 1'b1) begin
      // Reset Signals
      r_wack <= 1'b0;
    end
    else if (i_slave_wselect == 1'b1) begin
      if (i_slave_write == 1'b0) begin
        // De-asset acknowledge. If write signal 0 the acknowledge was captured.
        r_wack <= 1'b0;
      end
      else begin
        // When write = 1 then acknowledge the write operation.
        r_wack <= 1'b1;
      end
    end
  end

  assign o_slave_wack = r_wack;

endmodule // FIR_Filter
