///////////////////////////////////////////////////////////////////////////////
// File name    : FIR_Filter.v
// Author       : Jose R Garcia
// Create Date  : 18/05/2020 19:25:32
// Project Name : Reusable Unit Library
// Unit Name    : FIR_Filter
// Description  : Scalable FIR filter with adjustable fixed point generic
//
// Additional Comments:
//    Coefficients have to be generate in Octave/Matlab. Transposed.
///////////////////////////////////////////////////////////////////////////////

module FIR_Filter #(parameter P_COEFFICIENTS_MSB  = 7,   // xxxx.XXXX digits after the point
                              P_NUM_COEFFICIENTS  = 12,   // Number of filter coefficients
                              P_DATA_MSB          = 15,   // Must be smaller than g_IntegerDigits
                              P_WRITE_ADDRESS_MSB = 3,     // log2(P_NUM_COEFFICIENTS)-1
                              P_SYNC_RESET_EN     = 0
                              )
  (
   // Input Signals
   input i_clk,         // Main Clock
   input i_reset_sync,  // Synchronous Reset
   input i_reset_async, // Synchronous Reset
   // Streaming Data Signals
   output                o_ready_in,
   input                 i_valid_in,
   input  [P_DATA_MSB:0] i_data_in,  // Input Data
   input                 i_ready_out,
   output                o_valid_out,
   output [P_DATA_MSB:0] o_data_out, // Ouput Data
   // Asynch Memory Write Interface
   input                          i_wselect,    //
   input                          i_write,      //
   output                         o_wack,       //
   input  [P_COEFFICIENTS_MSB:0]  i_write_data, //
   input  [P_WRITE_ADDRESS_MSB:0] i_write_addr  //
  );

  /////////////////////////////////////////////////////////////////////////////
  // Internal Parameter Declarations
  /////////////////////////////////////////////////////////////////////////////
  localparam LP_ACCU_MSB           = (P_DATA_MSB+P_COEFFICIENTS_MSB+2)-1;
  /////////////////////////////////////////////////////////////////////////////
  // Internal Signal Declarations
  /////////////////////////////////////////////////////////////////////////////
  // Streaming In
  reg r_ready_in;
  // Streaming Out
  reg r_valid_out;
  // Accumulator Process
  reg signed [P_DATA_MSB:0]         r_data_buffer[0:P_NUM_COEFFICIENTS-1]; // Adder and Multiplication accumulator.
  reg signed [LP_ACCU_MSB:0]        r_product[0:P_NUM_COEFFICIENTS-1];     // Adder and Multiplication accumulator.
  reg signed [LP_ACCU_MSB:0]        r_product_tmp;                         // Adder and Multiplication accumulator.
  reg signed [P_DATA_MSB:0]         r_accumulator[0:P_NUM_COEFFICIENTS-1]; // Adder and Multiplication accumulator.
  reg signed [P_DATA_MSB:0]         r_data_buffer_out;
  // Memory Write interface Signals
  reg                               r_wack; //
  reg signed [P_COEFFICIENTS_MSB:0] r_coefficients[0:P_NUM_COEFFICIENTS-1];// Adder and Multiplication accumulator.
  // Counter
  integer ii;
  integer jj;
  integer hh;

  /////////////////////////////////////////////////////////////////////////////
  //            ********      Architecture Declaration      ********
  /////////////////////////////////////////////////////////////////////////////

  // Ready assignment
  assign o_ready_in = r_ready_in | i_valid_in;
  /////////////////////////////////////////////////////////////////////////////
  // Process     : Accumulator Process
  // Description : Accumulates the filtered samples.
  /////////////////////////////////////////////////////////////////////////////
  always @(negedge i_clk or posedge i_reset_async) begin
    if (i_reset_async == 1'b1) begin
      // Reset Signals
      r_valid_out <= 1'b0;
      for (ii = 0; ii < P_NUM_COEFFICIENTS; ii = ii+1) begin
        r_data_buffer[ii] <= 'b0;
      end
    end
    else if(i_reset_sync == 1'b1 && P_SYNC_RESET_EN == 1) begin
      // Reset Signals
      r_valid_out <= 1'b0;
      for (ii = 0; ii < P_NUM_COEFFICIENTS; ii = ii+1) begin
        r_data_buffer[ii] <= 'b0;
      end
    end
    else if (i_wselect == 1'b0 && r_ready_in && 1'b1 && i_valid_in == 1'b1) begin
      // Create r_valid_data_in
      r_valid_out <= 1'b1;
      // SHift data in
      r_data_buffer[0] <= i_data_in;
      for (ii = 0; ii < P_NUM_COEFFICIENTS-1; ii = ii+1) begin
        // Shift data in.
        r_data_buffer[ii+1] <= r_data_buffer[ii];
      end
      // First M_ACC
      r_product_tmp     = (r_data_buffer[0]*r_coefficients[0]);
      r_product[0]     <= r_product_tmp;
      r_accumulator[0] <= {r_product_tmp[LP_ACCU_MSB],
        r_product_tmp[LP_ACCU_MSB-2:P_DATA_MSB]};
      for (hh = 0; hh < P_NUM_COEFFICIENTS-1; hh = hh+1) begin
        // M_ACC
        r_product[hh+1]     <= r_data_buffer[hh+1] * r_coefficients[hh+1];
        r_accumulator[hh+1] <= r_accumulator[hh] + {
          r_product[hh+1][LP_ACCU_MSB],
          r_product[hh+1][LP_ACCU_MSB-2:P_DATA_MSB]};
      end
    end
    else if (i_wselect == 1'b1 || i_valid_in == 1'b0) begin
      // Create r_valid_data_in
      r_valid_out <= 1'b0;
    end
  end
  // Assign register values to output signals
  assign r_ready_in  = !i_wselect & i_ready_out;
  assign o_valid_out = r_valid_out;
  assign o_data_out  = r_accumulator[P_NUM_COEFFICIENTS-1];

  /////////////////////////////////////////////////////////////////////////////
  // Process     : Asynch Memory Write Data Process
  // Description : Creates a write interface
  /////////////////////////////////////////////////////////////////////////////
  always @(negedge i_clk or posedge i_reset_async) begin
    if (i_reset_async == 1'b1) begin
      // Reset Signals
      for(jj = 0; jj < P_NUM_COEFFICIENTS; jj = jj+1)
        r_coefficients[jj] <= 'h0;
    end
    else if(i_reset_sync == 1'b1 && P_SYNC_RESET_EN == 1) begin
      // Reset Signals
      for(jj = 0; jj < P_NUM_COEFFICIENTS; jj = jj+1)
        r_coefficients[jj] <= 'h0;
    end
    else if (i_wselect == 1'b1 && i_write == 1'b1 && r_wack == 1'b0) begin
        r_coefficients[i_write_addr] <= i_write_data;
    end
  end

  /////////////////////////////////////////////////////////////////////////////
  // Process     : Asynch Memory Write Acknowledge Process
  // Description : Creates a write interface
  /////////////////////////////////////////////////////////////////////////////
  always @(negedge i_clk or posedge i_reset_async) begin
    if (i_reset_async == 1'b1) begin
      // Reset Signals
      r_wack <= 1'b0;
    end
    else if(i_reset_sync == 1'b1 && P_SYNC_RESET_EN == 1) begin
      // Reset Signals
      r_wack <= 1'b0;
    end
    else if (i_wselect == 1'b1) begin
      if (i_write == 1'b0) begin
        r_wack <= 1'b0;
      end
      else begin
        r_wack <= 1'b1;
      end
    end
  end

  assign o_wack = r_wack;

endmodule // FIR_Filter
